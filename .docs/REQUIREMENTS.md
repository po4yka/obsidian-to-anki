# Сервис по конвертации вопросов в хранилище Obsidian в карточки Anki

Версия документа: 1.0 (2025-10-12)
Статус: Implemented (v0.1.0)

## 1. Цель и область применения

- **Цель:** автоматизировать преобразование пар «вопрос/ответ» из хранилища Obsidian в корректные карточки Anki формата APF с гарантией трассируемости и детерминизма.
- **Область:** заметки в `interview_questions/InterviewQuestions` с одной или несколькими парами Q/A на заметку (поддержка мультикарточности).
- **Важное:** двусторонняя синхронизация (Obsidian ↔ Anki) и обработка удалений входят в область ответственности инструмента.

## 2. Термины

- **Obsidian Vault** — локальное хранилище заметок.
- **Заметка** — markdown‑файл в vault, содержащий одну пару Q/A.
- **APF** — Anki Prompts Format: жёстко формализованный шаблон HTML‑блоков карточек, сопровождаемый линтерами и таксономией тегов.
- **Slug** — уникальный идентификатор карточки (lowercase‑dash) внутри батча.
- **Manifest** — JSON‑строка в конце блока карточки, дублирующая основные поля (slug, lang, type, tags).

## 3. Бизнес‑требования

- Брать файлы с одной или несколькими парами вопрос/ответ из `interview_questions/InterviewQuestions` и конвертировать их в карточки Anki (маппинг 1‑к‑N, где N ≥ 1).
- Для каждой пары Q/A формировать минимум две карточки: отдельную карточку на английском и отдельную карточку на русском языке, помечая их как элементы одной двуязычной группы.
- Поддерживать создание карточек разных типов APF (Simple, Missing/Cloze, Draw) в рамках одной заметки, выбирая тип автоматически или по явному указанию в фронтматтере/конфигурации.
- При выборе типа карты использовать приоритет: фронтматтер `anki_note_type` → конфигурационное правило → эвристики (наличие `{{c1::`/`{{c` для Cloze, маркеры рисунков для Draw) → `APF::Simple` по умолчанию.
- Использовать промпт/шаблон из `.docs/CARDS_PROMPT.md` и следовать правилам папки `.docs/APF Cards` (Doc A–F).
- Обеспечить однозначную трассируемость: из заметки понятно, к каким карточкам она относится (в т.ч. множественным), и наоборот.
- Поддержать обновления: изменение заметки в Obsidian приводит к обновлению соответствующих карточек в Anki; новые заметки — к созданию карточек; удаление карточек в Anki либо заметок в Obsidian корректно обрабатывается согласно политике синхронизации (см. раздел 9).
- Поддержать «сухой прогон» (dry‑run) для предпросмотра изменений без записи в Anki.
- Логи и метрики: количество обработанных/созданных/обновлённых/пропущенных карточек; предупреждения линтера APF.

## 4. Приоритизация (MoSCoW)

- **Must (обязательно):** 1‑к‑N конвертация; соответствие APF; детерминированный вывод; интеграция с AnkiConnect; обновление и удаление; базовая трассируемость; конфигурация путей и колоды; базовая двусторонняя синхронизация.
- **Should (желательно):** dry‑run; инкрементальная обработка по хешу содержимого; ретраи LLM и AnkiConnect; валидация тегов по таксономии; отчёт по качеству; детальная политика конфликтов для двустороннего sync.
- **Could (возможно позже):** поддержка CardType Draw; режим JSON (по флагу); golden‑тесты на формат; кроссплатформенность; интерактивное разрешение конфликтов.
- **Won’t (не планируется сейчас):** синхронизация метрик обучения/статистики Anki обратно в заметки.

## 5. Требования APF (соответствие)

Сервис должен формировать карточки строго по документации в `.docs/APF Cards` и `.docs/CARDS_PROMPT.md`:

- Обязательные «сентинелы» батча: первая строка `<!-- PROMPT_VERSION: apf-v2.1 -->`; далее `<!-- BEGIN_CARDS -->` ... `<!-- END_CARDS -->`; последняя строка `END_OF_CARDS`.
- Структура карточки: точные комментарии‑заголовки полей (Doc A), каждое поле на своём месте, по одному пустому строковому интервалу между полями.
- Типы карточек: Simple | Missing | Draw; выбирать минимально достаточный тип; для Missing — плотная нумерация клоузов 1..N.
- Теги: 3–6, snake_case, порядок: язык/инструмент → платформа/рантайм → домен → подтема; минимум один неязыковой тег; словарь из Doc B.
- Ограничения: строки ≤ 88 символов (кроме SVG data URI), никаких заполнителей/многоточий; экранирование HTML в коде; обязательный `<!-- manifest: {...} -->`.
- Батч‑правила: уникальные slug; распределение неязыковых тегов (см. Doc D); валидации линтером.
- Режим JSON включается только при `mode=json` в запросе; иначе всегда HTML‑блоки + manifest (Doc E).
- Рекомендации раннера: temperature ≤ 0.2, top_p ≤ 0.3 (не печатать в вывод).
- Поддержка нескольких note type: реализовать генерацию карточек минимум для `APF::Simple`, `APF::Missing (Cloze)` и `APF::Draw` (см. `.docs/APF Cards` и `.docs/APF_FIELD_GUIDE.md`). Тип по умолчанию — `APF::Simple`; конечный тип определяется цепочкой правил:
  1. Если во фронтматтере указан `anki_note_type`, использовать его (в т.ч. при множественных Q/A в заметке — поле действует на весь файл).
  2. Иначе применить конфигурационное сопоставление `question_kind` → note type.
  3. Если стандартные правила не сработали и в содержимом ответа найдены клоуз-разметка `{{c` или директива `anki_note_type: missing`, выбрать `APF::Missing (Cloze)`.
  4. Если контент содержит блок `![draw](` или явный маркер `<!-- DRAW_CARD -->`, выбрать `APF::Draw`.
  5. В остальных случаях использовать `APF::Simple`.
  Для каждого типа определить маппинг полей (Front, Back, Additional, Cloze1/ClozeN, Drawing и др.) и следовать требованиям конкретного шаблона, включая нумерацию клоузов и обязательность поля Drawing.
- Совместимость с APF 3.x: выводимые карточки обязаны импортироваться в Anki с типами из пакета «APF (3.0.0) — Demo» без ручных правок. Unit/интеграционные тесты должны проверять наличие всех требуемых полей и соответствие имени note type конфигурации.

## 6. Структура заметок Obsidian

- **Каталог:** локальный Obsidian Vault (путь настраивается), целевая директория `interview_questions/InterviewQuestions` с тематическими подпапками вида `40-Android`, `70-Kotlin`, `60-CompSci`, совпадающими со значением `topic`.
- **Типы заметок:** к обработке допускаются только Q&A файлы с префиксом `q-` и расширением `.md`; файлы `c-*.md`, `moc-*.md`, административные документы и шаблоны игнорируются.
- **YAML-фронтматтер:** начинается сразу после первого `---` и содержит поля `id`, `title`, `aliases`, `topic`, `subtopics`, `question_kind`, `difficulty`, `original_language`, `language_tags`, `source`, `source_note`, `status`, `moc`, `related`, `created`, `updated`, `tags`. Инструмент валидирует обязательные поля, сравнивает `topic` с местоположением файла, наследует теги (включая производные из `topic`/`subtopics`) в Anki.
- **Контентные секции:** каждая пара Q/A оформлена блоком `# Question (EN)` → `# Вопрос (RU)` → `---` → `## Answer (EN)` → `## Ответ (RU)` с последующими `## Follow-ups`, `## References`, `## Related Questions` (если присутствуют). Вопросы обычно оформлены цитатами (`> ...`), ответы содержат списки, таблицы, кодовые блоки и чеклисты; горизонтальный разделитель `---` отделяет последовательные блоки.
- **Мультипары:** одна заметка может содержать несколько последовательных блоков Q/A. Парсер обязан устойчиво находить каждый блок, даже если перед ним размещены вводные заголовки или произвольный текст.
- **Вводные секции:** заголовки вроде `# App Performance Optimization Checklist for Android` и сопутствующий текст между фронтматтером и первым `# Question (EN)` не должны трактоваться как отдельные карточки, но могут использоваться как контекст в Additional/Other notes.
- **Языковые требования:** `language_tags` почти всегда `[en, ru]`. При отсутствии содержимого для одной из локалей сервис фиксирует предупреждение, пропуская генерацию карточки для этой локали и сохраняя двуязычную непротиворечивость.
- **Проверки `language_tags`:** массив обязателен; допустимые значения — `en`, `ru` (и другие поддерживаемые локали по конфигурации). Инструмент сверяет массив с фактическим наличием секций `Question/Answer` для каждой локали: отсутствие секции при наличии тега трактуется как ошибка импорта, отсутствие тега при наличии секции — как предупреждение и автоматическое расширение массива. Поле `original_language` должно входить в `language_tags`; несоответствия логируются.
- **Ссылки и контекст:** разделы `## Follow-ups`, `## References`, `## Related Questions`, а также поля `related`, `moc`, `source`, `source_note` используются для заполнения служебных полей карточки (например, Additional/Other notes) и удержания связи с исходной базой знаний.
- **Хронометки:** значения `created` и `updated` применяются для инкрементальной синхронизации и диагностики; несогласованность дат или пропуски отчётливо логируются.
- **Кодировка:** UTF‑8; поддерживаются Markdown и встроенные фрагменты кода, включая блоки с подсветкой.

## 7. Парсинг Markdown в пары Q/A

1. **Предобработка:**
   - Считать и разобрать YAML-фронтматтер (между первым и вторым `---` включительно), сохранить метаданные.
   - Оставшуюся часть файла нормализовать по переводу строк (`\n`), удалить BOM и завершающие пробелы.
2. **Поиск секций вопросов:**
   - Сканировать документ на заголовки уровня `#` с текстом `Question (EN)` и `Вопрос (RU)`. Регистрозависимы; допускаются ведущие/хвостовые пробелы и Markdown-ссылки внутри, но не альтернативные формулировки.
   - Каждую пару `# Question (EN)` + последующий `# Вопрос (RU)` трактовать как начало Q/A блока. Между ними допускается только Markdown-контент, который относится к соответствующей локали (обычно цитаты `> ...`).
3. **Разделитель блока:**
   - После `# Вопрос (RU)` ожидается горизонтальная линия `---` (три дефиса на отдельной строке). Отсутствие линии фиксируется как ошибка структуры; парсер пытается продолжать, но помечает карточку как требующую ручной проверки.
4. **Извлечение ответов:**
   - После разделителя допустимы заголовки `## Answer (EN)` и `## Ответ (RU)` (строго `##`). Контент до следующего заголовка того же уровня (`##`) или конца файла принадлежит текущему ответу.
   - Дополнительные секции (`## Follow-ups`, `## References`, `## Related Questions`) считаются мета-блоками и не входят в основное поле ответа; информация из них записывается в Additional/Other notes карточки.
5. **Повторяющиеся блоки:**
   - После `## Related Questions` (или отсутствия дополнительных секций) парсер ищет следующий `# Question (EN)`; если найден, начинается новый цикл (пункт 2). Любой контент между блоками (например, заголовки разделов, списки) сохраняется как префикс нового блока и попадает в Additional/Other notes.
6. **Валидация:**
   - В каждом блоке должны присутствовать обе языковые пары вопросов и ответов. Отсутствие любой секции делает блок неполным: он логируется и пропускается, если не указан режим принудительной генерации с заглушками.
   - Markdown внутри цитат/ответов не модифицируется, кроме нормализации переноса строк и удаления лишних пробелов по краям.
7. **Выходные данные:**
   - Для каждой пары формируется объект `{slug_base, lang, question_html, answer_html, followups, references, related_questions, context}`. Дополнительные поля (`source_path`, `source_anchor`, `card_index`) вычисляются на этапе сборки карточки.

## 8. Маппинг, slug и идентификация (1‑к‑N)

- `slug` каждой карточки должен быть стабильным и выводимым из заметки/секции (например, на основе относительного пути, имени файла и локального индекса пары) с обязательным языковым суффиксом (`-en`, `-ru`) и явным указанием `lang` в manifest. Требование к коллизиям: сервис обязан обнаруживать и предотвращать дубликаты slug внутри батча.
- Алгоритм формирования `slug_base`: (1) вычислить путь заметки относительно `SOURCE_DIR` и заменить разделители каталогов на `-`; (2) извлечь имя файла без расширения (`q-...--...--...`), привести к lowercase и заменить любые недопустимые символы на `-`; (3) определить порядковый номер пары `card_index` (1‑based) внутри заметки, дополнить до двух цифр (`01`, `02`, ...); (4) собрать `slug_base = <rel_path_sanitized>-p<card_index>` с коллапсированием повторных дефисов и усечением до 70 символов; (5) итоговый slug = `slug_base-<lang>` (`slug_base-en`, `slug_base-ru`). При превышении лимита или коллизии добавлять контрольный хеш (`-<hash6>`). Все изменения slug должны отражаться в manifest и использоваться как ключ синхронизации.
- **Правила разрешения коллизий:**
  1. Проверять уникальность slug на уровне текущего батча (все формируемые карточки до записи). Если уже существует slug с таким же именем и языком, переключиться в режим разрешения.
  2. В режиме разрешения добавлять к `slug_base` стабильный хеш из состава: `source_path`, `card_index`, `lang`, `sha1(truncated(question_text+answer_text))`. Первые 6 символов хеша (`hash6`) добавляются как `slug_base = <slug_base>-<hash6>`.
  3. Если конфликт сохраняется (что возможно только при идентичном содержимом), допускается повторное добавление счётчика `-v2`, `-v3` и т.п., но событие фиксируется как критическое (не должно происходить при корректном исходном наборе).
  4. При изменении slug сервис обязан выполнить маппинг на существующий GUID в Anki по manifest (`slug_base`, `lang`, `source_path`, `card_index`). Если карточка найдена с прежним slug, обновить manifest и переназначить slug (обновление по GUID).
  5. Сохранить таблицу соответствий прежний slug → новый slug в отчёте синхронизации.
- **Effects mapping:** manifest включает `slug`, `slug_base`, `lang`, `source_path` (относительный путь к заметке), `source_anchor` (`p01`, `p02`, ...), `note_id` (`id` из YAML), `note_title`, `card_index`, `hash6` (если применён). Набор полей обязателен и используется как первичный ключ при повторных запусках.
- **Обратные ссылки:** поле карточки Anki `Other notes` должно начинаться с строки вида `Ref: [[<source_path>#<source_anchor>]]`, обеспечивающей переход в Obsidian. Допустимо добавлять дополнительные строки (Follow-ups, References) после ссылки.
- **Синхронизация с YAML:** при наличии во фронтматтере массива `anki_slugs` сервис сравнивает его с текущим набором slug и обновляет (добавляет/удаляет) значения. При отсутствии массива он может быть создан (конфигурируемо), что упрощает двустороннюю трассировку.
- Дополнительно карта наследует теги из поля `tags` и `subtopics`, чтобы поиск в Anki позволял фильтровать по темам, а manifest и `Other notes` дают человеку и автоматике возможность вернуться в исходную заметку.
- При повторных запусках соответствие карточек опирается на slug/manifest и/или Anki‑GUID; при изменениях множества пар поддерживается корректный ремап без потери истории.

## 9. Синхронизация и политика обновлений

- Источник истины — Obsidian для содержимого карточек; Anki — для факта существования карточек и их GUID.
- Изменение заметки → обновление соответствующих карточек (по slug/manifest), сохраняя GUID.
- Новые заметки/новые пары → добавление новых карточек.
- Удаления:
  - Удаление пары в заметке → удаление/архивация соответствующей карточки в Anki (режим выбирается настройкой).
  - Удаление карточки в Anki → восстановление из Obsidian при следующем запуске (если пара всё ещё существует).
- Определение изменений: по хешу содержимого извлечённых пар Q/A на уровне секции; возможна эвристика по дате изменения файла/якорей; точный алгоритм — в техдизайне.
- Режимы: `dry-run` (план create/update/delete/restore/skip, превью), `apply` (выполнение плана). Политика конфликтов: Should — конфигурируемая (prefer-obsidian | prefer-anki | manual-later).

## 10. Технические требования

- Язык: Python 3.14.0.
- Anki: взаимодействие через AnkiConnect (локальный HTTP API).
- LLM: OpenRouter, модель «gpt‑5 thinking» со structured output; соблюдать рекомендации по детерминизму (temperature ≤ 0.2, top_p ≤ 0.3).
- Тип карточек: APF; можно ориентироваться на колоду «APF (3.0.0) — Demo» для совместимости полей.

## 11. Конфигурация

- Переменные/файл конфигурации:
  - `VAULT_PATH` — путь к Obsidian Vault.
  - `SOURCE_DIR` — относительный путь к каталогу с Q/A (по умолчанию `interview_questions/InterviewQuestions`).
  - `ANKI_CONNECT_URL` — URL AnkiConnect (по умолчанию `http://127.0.0.1:8765`).
  - `ANKI_DECK_NAME` — целевая колода.
  - `ANKI_NOTE_TYPE` — тип APF note.
  - `OPENROUTER_API_KEY`, `OPENROUTER_MODEL` — доступ и модель LLM.
  - `LLM_TEMPERATURE`, `LLM_TOP_P` — параметры детерминизма.
  - `RUN_MODE` — `apply` | `dry-run`.

## 12. Нефункциональные требования

- **Детерминизм:** одинаковый вход → одинаковый APF‑выход.
- **Идемпотентность:** повторный запуск на неизменённом наборе файлов не приводит к изменению карточек.
- **Производительность:** базовый ориентир — ≥ 20 заметок/мин при локальном AnkiConnect и стабильном LLM‑ответе.
- **Надёжность:** ретраи сетевых вызовов; таймауты; отложенное повторение ошибок.
- **Наблюдаемость:** структурированные логи; счётчики по операциям; отчёт об ошибках линтера APF.

## 13. Валидация и тестирование

- **Unit‑тесты:**
  - парсинг заметки в набор Q/A (1‑к‑N) с якорями секций;
  - построение APF‑карточек по `CARDS_PROMPT.md` (golden‑снимки);
  - валидация тегов и заголовков полей (Doc A/B/D).
- **Интеграционные тесты:**
  - взаимодействие с AnkiConnect (заглушка);
  - потоки create/update/delete/restore;
  - детерминизм настроек LLM.
- **E2E (dry‑run):** на тестовом наборе заметок с отчётом (create/update/delete/restore/skip) и проходом APF‑линтера.

## 14. Критерии приёмки

- На входе каталог с ≥ 5 заметками (включая ≥ 2 с несколькими парами Q/A); на выходе — созданные/обновлённые/удалённые/восстановленные карточки в целевой колоде, соответствующие APF.
- Линтер APF (Doc D) не сообщает ошибок; предупреждения ≤ согласованного порога.
- Повторный запуск без изменений не приводит к диффам в Anki (идемпотентность) и сохраняет стабильность GUID.
- Dry‑run показывает корректный план изменений (включая delete/restore) и совпадает с фактическими изменениями в режиме apply.

## 15. Матрица трассируемости

Ниже приведена матрица соответствия требований проектным артефактам: разделам этого документа, сопутствующим документациям APF, предполагаемым модулям/задачам реализации и тестам. Колонка «Статус» отражает текущее состояние выполнения.

| ID | Требование (кратко) | Приоритет | Связанные документы | Модули/задачи | Тесты | Линтер/политики | Статус |
| --- | --- | --- | --- | --- | --- | --- | --- |
| BR‑1 | 1‑к‑N заметка→карточки | Must | §3, §7 | parser, apf_generator | E2E‑01, INT‑01, UNIT‑parse‑01 | Doc A | План |
| BR‑2 | Двуязычные карточки EN/RU и группировка | Must | §3, §8 | apf_generator | UNIT‑lang‑01, E2E‑02 | Doc A (manifest.lang) | План |
| BR‑3 | Автовыбор типа карты (Simple/Missing/Draw) | Should | §5 | apf_generator | UNIT‑type‑01 | Doc D | План |
| APF‑1 | Сентинелы/структура блока | Must | §5, CARDS_PROMPT, Doc A | apf_generator | LINT‑A, UNIT‑apf‑a | Doc A | План |
| APF‑2 | Таксономия тегов (3–6, порядок) | Must | §5, Doc B | tagger | UNIT‑tag‑01, LINT‑tag | Doc B/D | План |
| APF‑3 | Cloze: плотность 1..N | Must | §5, Doc D | apf_generator | LINT‑cloze | Doc D | План |
| PARSE‑1 | YAML‑фронтматтер: чтение/валидация | Must | §6 | parser | UNIT‑yaml‑01 | — | План |
| PARSE‑2 | Парсинг мультипар Q/A | Must | §7 | parser | UNIT‑parse‑02, INT‑parse‑01 | — | План |
| MAP‑1 | Стабильный slug (+‑en/‑ru) | Must | §8 | slugger | UNIT‑slug‑01 | — | План |
| MAP‑2 | Обратные ссылки Ref в карточке | Should | §8 | apf_generator | INT‑ref‑01 | — | План |
| SYNC‑1 | Create/Update/Delete/Restore | Must | §9 | sync_engine, anki_client | INT‑crud‑01, E2E‑03 | — | План |
| SYNC‑2 | Политика конфликтов (prefer‑obsidian/anki) | Should | §9 | sync_engine | INT‑conflict‑01 | — | План |
| CFG‑1 | Конфигурация переменных/флагов | Must | §10 | config | UNIT‑config‑01 | — | План |
| NFR‑1 | Детерминизм вывода | Must | §11 | — | REGR‑det‑01 | — | План |
| NFR‑2 | Идемпотентность запуска | Must | §11 | — | E2E‑idemp‑01 | — | План |
| TEST‑1 | Dry‑run: корректный план изменений | Must | §9, §13 | — | E2E‑dryrun‑01 | — | План |
